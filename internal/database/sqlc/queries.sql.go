// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteDirectoryByID = `-- name: DeleteDirectoryByID :exec
DELETE FROM directories WHERE id = ?
`

func (q *Queries) DeleteDirectoryByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDirectoryByID, id)
	return err
}

const getBackupOperations = `-- name: GetBackupOperations :many
SELECT id, started_at, finished_at, operation, parameters, status FROM backup_operations ORDER BY id DESC LIMIT ?
`

func (q *Queries) GetBackupOperations(ctx context.Context, limit int64) ([]BackupOperation, error) {
	rows, err := q.db.QueryContext(ctx, getBackupOperations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupOperation
	for rows.Next() {
		var i BackupOperation
		if err := rows.Scan(
			&i.ID,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Operation,
			&i.Parameters,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContentByID = `-- name: GetContentByID :one

SELECT id, created_at, encrypted_content_id FROM contents WHERE id = ? LIMIT 1
`

// Content queries
func (q *Queries) GetContentByID(ctx context.Context, id string) (Content, error) {
	row := q.db.QueryRowContext(ctx, getContentByID, id)
	var i Content
	err := row.Scan(&i.ID, &i.CreatedAt, &i.EncryptedContentID)
	return i, err
}

const getDirectoriesByPathPrefix = `-- name: GetDirectoriesByPathPrefix :many
SELECT id, path, created_at, encrypted FROM directories WHERE path LIKE ?1 ORDER BY path
`

func (q *Queries) GetDirectoriesByPathPrefix(ctx context.Context, path string) ([]Directory, error) {
	rows, err := q.db.QueryContext(ctx, getDirectoriesByPathPrefix, path)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Directory
	for rows.Next() {
		var i Directory
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.CreatedAt,
			&i.Encrypted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectoryByPath = `-- name: GetDirectoryByPath :one


SELECT id, path, created_at, encrypted FROM directories WHERE path = ? LIMIT 1
`

// SQL queries for bt database operations
// sqlc will generate type-safe Go code from these queries
// See: https://docs.sqlc.dev/en/latest/
// Directory queries
func (q *Queries) GetDirectoryByPath(ctx context.Context, path string) (Directory, error) {
	row := q.db.QueryRowContext(ctx, getDirectoryByPath, path)
	var i Directory
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.CreatedAt,
		&i.Encrypted,
	)
	return i, err
}

const getFileByDirectoryAndName = `-- name: GetFileByDirectoryAndName :one
SELECT id, name, directory_id, current_snapshot_id, deleted FROM files WHERE directory_id = ? AND name = ? LIMIT 1
`

type GetFileByDirectoryAndNameParams struct {
	DirectoryID string `json:"directory_id"`
	Name        string `json:"name"`
}

func (q *Queries) GetFileByDirectoryAndName(ctx context.Context, arg GetFileByDirectoryAndNameParams) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByDirectoryAndName, arg.DirectoryID, arg.Name)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirectoryID,
		&i.CurrentSnapshotID,
		&i.Deleted,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one

SELECT id, name, directory_id, current_snapshot_id, deleted FROM files WHERE id = ? LIMIT 1
`

// File queries
func (q *Queries) GetFileByID(ctx context.Context, id string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirectoryID,
		&i.CurrentSnapshotID,
		&i.Deleted,
	)
	return i, err
}

const getFileSnapshotByFileAndContent = `-- name: GetFileSnapshotByFileAndContent :one
SELECT id, file_id, content_id, created_at, size, permissions, uid, gid, accessed_at, modified_at, changed_at, born_at FROM file_snapshots WHERE file_id = ? AND content_id = ? LIMIT 1
`

type GetFileSnapshotByFileAndContentParams struct {
	FileID    string `json:"file_id"`
	ContentID string `json:"content_id"`
}

func (q *Queries) GetFileSnapshotByFileAndContent(ctx context.Context, arg GetFileSnapshotByFileAndContentParams) (FileSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getFileSnapshotByFileAndContent, arg.FileID, arg.ContentID)
	var i FileSnapshot
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ContentID,
		&i.CreatedAt,
		&i.Size,
		&i.Permissions,
		&i.Uid,
		&i.Gid,
		&i.AccessedAt,
		&i.ModifiedAt,
		&i.ChangedAt,
		&i.BornAt,
	)
	return i, err
}

const getFileSnapshotByID = `-- name: GetFileSnapshotByID :one

SELECT id, file_id, content_id, created_at, size, permissions, uid, gid, accessed_at, modified_at, changed_at, born_at FROM file_snapshots WHERE id = ? LIMIT 1
`

// FileSnapshot queries
func (q *Queries) GetFileSnapshotByID(ctx context.Context, id string) (FileSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getFileSnapshotByID, id)
	var i FileSnapshot
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ContentID,
		&i.CreatedAt,
		&i.Size,
		&i.Permissions,
		&i.Uid,
		&i.Gid,
		&i.AccessedAt,
		&i.ModifiedAt,
		&i.ChangedAt,
		&i.BornAt,
	)
	return i, err
}

const getFileSnapshotsByFileID = `-- name: GetFileSnapshotsByFileID :many
SELECT id, file_id, content_id, created_at, size, permissions, uid, gid, accessed_at, modified_at, changed_at, born_at FROM file_snapshots WHERE file_id = ? ORDER BY created_at
`

func (q *Queries) GetFileSnapshotsByFileID(ctx context.Context, fileID string) ([]FileSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getFileSnapshotsByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileSnapshot
	for rows.Next() {
		var i FileSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.ContentID,
			&i.CreatedAt,
			&i.Size,
			&i.Permissions,
			&i.Uid,
			&i.Gid,
			&i.AccessedAt,
			&i.ModifiedAt,
			&i.ChangedAt,
			&i.BornAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByDirectoryID = `-- name: GetFilesByDirectoryID :many
SELECT id, name, directory_id, current_snapshot_id, deleted FROM files WHERE directory_id = ?
`

func (q *Queries) GetFilesByDirectoryID(ctx context.Context, directoryID string) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, getFilesByDirectoryID, directoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DirectoryID,
			&i.CurrentSnapshotID,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxBackupOperationID = `-- name: GetMaxBackupOperationID :one
SELECT CAST(COALESCE(MAX(id), 0) AS INTEGER) AS max_id FROM backup_operations
`

func (q *Queries) GetMaxBackupOperationID(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMaxBackupOperationID)
	var max_id int64
	err := row.Scan(&max_id)
	return max_id, err
}

const insertBackupOperation = `-- name: InsertBackupOperation :one

INSERT INTO backup_operations (started_at, operation, parameters)
VALUES (?, ?, ?)
RETURNING id, started_at, finished_at, operation, parameters, status
`

type InsertBackupOperationParams struct {
	StartedAt  time.Time `json:"started_at"`
	Operation  string    `json:"operation"`
	Parameters string    `json:"parameters"`
}

// Backup operation queries
func (q *Queries) InsertBackupOperation(ctx context.Context, arg InsertBackupOperationParams) (BackupOperation, error) {
	row := q.db.QueryRowContext(ctx, insertBackupOperation, arg.StartedAt, arg.Operation, arg.Parameters)
	var i BackupOperation
	err := row.Scan(
		&i.ID,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Operation,
		&i.Parameters,
		&i.Status,
	)
	return i, err
}

const insertContent = `-- name: InsertContent :one
INSERT INTO contents (id, created_at, encrypted_content_id)
VALUES (?, ?, ?)
RETURNING id, created_at, encrypted_content_id
`

type InsertContentParams struct {
	ID                 string         `json:"id"`
	CreatedAt          time.Time      `json:"created_at"`
	EncryptedContentID sql.NullString `json:"encrypted_content_id"`
}

func (q *Queries) InsertContent(ctx context.Context, arg InsertContentParams) (Content, error) {
	row := q.db.QueryRowContext(ctx, insertContent, arg.ID, arg.CreatedAt, arg.EncryptedContentID)
	var i Content
	err := row.Scan(&i.ID, &i.CreatedAt, &i.EncryptedContentID)
	return i, err
}

const insertDirectory = `-- name: InsertDirectory :one
INSERT INTO directories (id, path, created_at, encrypted)
VALUES (?, ?, ?, ?)
RETURNING id, path, created_at, encrypted
`

type InsertDirectoryParams struct {
	ID        string    `json:"id"`
	Path      string    `json:"path"`
	CreatedAt time.Time `json:"created_at"`
	Encrypted int64     `json:"encrypted"`
}

func (q *Queries) InsertDirectory(ctx context.Context, arg InsertDirectoryParams) (Directory, error) {
	row := q.db.QueryRowContext(ctx, insertDirectory,
		arg.ID,
		arg.Path,
		arg.CreatedAt,
		arg.Encrypted,
	)
	var i Directory
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.CreatedAt,
		&i.Encrypted,
	)
	return i, err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO files (id, name, directory_id, current_snapshot_id, deleted)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, directory_id, current_snapshot_id, deleted
`

type InsertFileParams struct {
	ID                string         `json:"id"`
	Name              string         `json:"name"`
	DirectoryID       string         `json:"directory_id"`
	CurrentSnapshotID sql.NullString `json:"current_snapshot_id"`
	Deleted           bool           `json:"deleted"`
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.ID,
		arg.Name,
		arg.DirectoryID,
		arg.CurrentSnapshotID,
		arg.Deleted,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirectoryID,
		&i.CurrentSnapshotID,
		&i.Deleted,
	)
	return i, err
}

const insertFileSnapshot = `-- name: InsertFileSnapshot :one
INSERT INTO file_snapshots (id, file_id, content_id, created_at, size, permissions, uid, gid, accessed_at, modified_at, changed_at, born_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, file_id, content_id, created_at, size, permissions, uid, gid, accessed_at, modified_at, changed_at, born_at
`

type InsertFileSnapshotParams struct {
	ID          string       `json:"id"`
	FileID      string       `json:"file_id"`
	ContentID   string       `json:"content_id"`
	CreatedAt   time.Time    `json:"created_at"`
	Size        int64        `json:"size"`
	Permissions int64        `json:"permissions"`
	Uid         int64        `json:"uid"`
	Gid         int64        `json:"gid"`
	AccessedAt  time.Time    `json:"accessed_at"`
	ModifiedAt  time.Time    `json:"modified_at"`
	ChangedAt   time.Time    `json:"changed_at"`
	BornAt      sql.NullTime `json:"born_at"`
}

func (q *Queries) InsertFileSnapshot(ctx context.Context, arg InsertFileSnapshotParams) (FileSnapshot, error) {
	row := q.db.QueryRowContext(ctx, insertFileSnapshot,
		arg.ID,
		arg.FileID,
		arg.ContentID,
		arg.CreatedAt,
		arg.Size,
		arg.Permissions,
		arg.Uid,
		arg.Gid,
		arg.AccessedAt,
		arg.ModifiedAt,
		arg.ChangedAt,
		arg.BornAt,
	)
	var i FileSnapshot
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ContentID,
		&i.CreatedAt,
		&i.Size,
		&i.Permissions,
		&i.Uid,
		&i.Gid,
		&i.AccessedAt,
		&i.ModifiedAt,
		&i.ChangedAt,
		&i.BornAt,
	)
	return i, err
}

const updateBackupOperationFinished = `-- name: UpdateBackupOperationFinished :exec
UPDATE backup_operations SET finished_at = ?, status = ? WHERE id = ?
`

type UpdateBackupOperationFinishedParams struct {
	FinishedAt sql.NullTime `json:"finished_at"`
	Status     string       `json:"status"`
	ID         int64        `json:"id"`
}

func (q *Queries) UpdateBackupOperationFinished(ctx context.Context, arg UpdateBackupOperationFinishedParams) error {
	_, err := q.db.ExecContext(ctx, updateBackupOperationFinished, arg.FinishedAt, arg.Status, arg.ID)
	return err
}

const updateFileCurrentSnapshot = `-- name: UpdateFileCurrentSnapshot :exec
UPDATE files SET current_snapshot_id = ? WHERE id = ?
`

type UpdateFileCurrentSnapshotParams struct {
	CurrentSnapshotID sql.NullString `json:"current_snapshot_id"`
	ID                string         `json:"id"`
}

func (q *Queries) UpdateFileCurrentSnapshot(ctx context.Context, arg UpdateFileCurrentSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, updateFileCurrentSnapshot, arg.CurrentSnapshotID, arg.ID)
	return err
}

const updateFileDirectoryAndName = `-- name: UpdateFileDirectoryAndName :exec
UPDATE files SET directory_id = ?, name = ? WHERE id = ?
`

type UpdateFileDirectoryAndNameParams struct {
	DirectoryID string `json:"directory_id"`
	Name        string `json:"name"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateFileDirectoryAndName(ctx context.Context, arg UpdateFileDirectoryAndNameParams) error {
	_, err := q.db.ExecContext(ctx, updateFileDirectoryAndName, arg.DirectoryID, arg.Name, arg.ID)
	return err
}
